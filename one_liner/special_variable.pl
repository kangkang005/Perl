# @web: https://www.junmajinlong.com/perl/perl_options_vars/

=pod
=head1 $\
表示 print 函数的输出行分隔符。默认为 undef，所以 print 默认输出时两端数据总是连在一起的。
可以指定为换行符 \n，这样 print 输出每段数据都会自带换行符。
C<<
$ perl -e '$\ = "\n";print "haha"'
haha
>>
但必须注意，对于 perl 一行式程序的 - p 选项，它通过 <> 读取数据时会保留每一行的尾随换行符
(除非在 - e 表达式中使用了 chomp/chop)，这时不应该额外设置 $\ = "\n"，否则每行后面都会多输出一空行。

=head1 $/
表示读取文件时的输入行分隔符，默认为换行符 \n。在读取文件的时候，通过该特殊变量可以控制如何分行。
可以设置为多个字符。
如果设置为 undef，表示一次性从文件头一直读取到文件尾当作一行。
如果设置为空 "" 或 \n\n，表示按段落读取。不同的是：
1. 设置为空 "" 时，表示压缩连续空行为单个空行，压缩后的单空行属于当前段落
2. 设置为 \n\n 则盲目地认为下一行一直属于当前段落，即使是空行，也即是不会压缩连续空行

=head1 $.
$. 表示当前处理的行的行号。
实际上，它表示的是当前正在被打开的文件句柄的行号计数器。只要文件句柄不显式关闭，行号计数器就不会重置 (open 的隐式关闭以及 reopen 都不会重置)。
<> 读取 ARGV 文件时从不关闭文件句柄，所以在一行式 perl 程序中使用了 - n/-p 时，多个参数文件的行号是连续下去而不会重置的。
如果确实想要重置 <> 所读取的每个文件的行号，可以通过 eof 函数来判断，在到了文件底部的时候就关闭当前处理的文件。
C<<
while(<>){
    print "$. $_\n";
} continue {
    close(ARGV) if eof   #注意，不是eof()
}
>>
例如：
C<<
$ perl -e 'while(<>){print "$. $_"} continue {close(ARGV) if eof}'
>>
eof 和 eof () 是不同的，前者判断每个文件的文件尾部，后者则判断最后一个文件的尾部 (也就是无内容可读了)。所以，下面的表示在最后一个文件的前面插入一行分割线。
C<<
while(<>){
    print "-" x 30,"\n" if eof();
    print "$. $_"
}
>>
=cut