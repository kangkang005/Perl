# @web: https://www.junmajinlong.com/perl/perl_re/index.html

=head
首先固化分组不是一种分组，所以无法去引用它。它和【占有优先】匹配模式 (贪婪匹配、惰性匹配、占有优先匹配三种匹配模式，见后文) 是等价的除了这两种称呼，在不同的书、不同的语言里还有一种称呼：原子匹配。

它的表示形式类似于分组 (?>)，所以有些地方将其称呼为【固化分组】。再次说明，固化分组不是分组，无法进行引用。如果非要将其看作是分组，可以将其理解为被限定的匿名分组：不捕获，只分组。

1.按照【占有优先】的字面意义来理解比较容易：只要匹配成功了，就绝不回溯。
2.如果按照固化分组的概念来理解，就是将匹配成功的内容放进分组后，将其固定，不允许进行回溯。但是需要注意，这里的不回溯是放进分组中的内容不会回溯给分组外面，而分组内部的内容是可以回溯的。
如果不知道什么是回溯，看完下面的例子就明白。

例如 hello world 可以被 hel.* world 成功匹配，但不能被 hel(?>.*) world 匹配。因为正常情况下，.* 匹配到所有内容，然后往回释放已匹配的内容直到释放完空格为止，这种往回释放字符的行为在正则术语中称为【回溯】。而固化分组后，.* 已匹配后面所有内容，这些内容一经匹配绝不交回，即无法回溯。

但是，如果正则表达式是 hel(?>.* world)，即将原来分组外面的内容放进了分组内部，这时在分组内部是会回溯的，也就是说能匹配 hello world。
=cut;
$str="ma longshuai gao xiaofang";
if($str =~ /ma (?>long.*)/){     # 成功
    # longshuai gao xiaofang
    print "matched1\n";
}

if($str =~ /ma (?>long.*)gao/){   # 失败
    # longshuai gao xiaofang
    print "matched2\n";
}

if($str =~ /ma (?>long.*gao)/){   # 成功
    # longshuai gao
    print "matched3\n";
}

if($str =~ /ma (?>long.*g)ao/){   # 失败
    # longshuai gao xiaofang
    print "matched4\n";
}
# 固化分组看上去挺简单的，此处也仅介绍了它最简单的形式。但实际上固化分组很复杂，
# 它涉及了非常复杂的正则引擎匹配原理和回溯机制。如果有兴趣，可以阅读《精通正则表达式》一书的第四章。